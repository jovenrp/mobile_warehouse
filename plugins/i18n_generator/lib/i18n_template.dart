// ignore_for_file: always_specify_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes
// ignore_for_file: unnecessary_brace_in_string_interps

class I18nTemplate {
  RegExp stringInterpolationRegExp = RegExp(
    r'({\s*[a-z]+\s*}+)',
    caseSensitive: false,
    multiLine: true,
  );

  String license = '''
/// Generate by [resource_generator](https://github.com/CaiJingLong/flutter_resource_generator) library.
/// PLEASE DO NOT EDIT MANUALLY.
///
// ignore_for_file: non_constant_identifier_names,unnecessary_brace_in_string_interps,non_constant_identifier_names

/// WARNING: This file is automatically generated. DO NOT EDIT, all your changes would be lost.\n
''';

  String get classDeclare => 'class I18nLookup {\n';
  String get classDeclareFunctions => '''

  Map<String, dynamic> _content = {};

  set content(Map<String, dynamic> loadedContent) {
    _content = loadedContent;
  }

  RegExp stringInterpolationRegExp = RegExp(
    r'({\s*[a-z]+\s*}+)',
    caseSensitive: false,
    multiLine: true,
  );

  String parsePlaceholder(fallbackValue, String key, Map<String, dynamic> placeholders) {
    final String? value = _content[key];
    if (value != null) {
      return value.replaceAllMapped(stringInterpolationRegExp, (match) {
        final matchString = value.substring(match.start, match.end);
        final parameter = value.substring(match.start + 1, match.end - 1).trim();

        if (!placeholders.containsKey(parameter) || placeholders[parameter] == null) {
          return matchString;
        }
        return placeholders[parameter].toString();
      });
    }
    return fallbackValue;
  }
\n''';

  String get blankLine => '\n\n';

  List<String> parseParameters(value) {
    final Iterable matches = stringInterpolationRegExp.allMatches(value);

    final parameters = <String>[];
    matches.forEach((match) {
      final parameter = value.substring(match.start + 1, match.end - 1).trim();

      if (parameters.contains(parameter)) {
        return;
      }
      parameters.add(parameter);
    });

    return parameters;
  }

  String get tripleQuotes => '\'\'\'';
  String get classDeclareFooter => '}\n';

  String fallbackValue(value) {
    final Iterable matches = stringInterpolationRegExp.allMatches(value);
    if (matches.isNotEmpty) {
      value = value.replaceAllMapped(stringInterpolationRegExp, (match) {
        final matchString = value.substring(match.start, match.end);

        return '''\$${matchString}''';
      });
    }

    return '\'\'\'${value}\'\'\'';
  }

  String formatFiled(String key, dynamic value) {
    if (value != null) {
      final parameters = parseParameters(value);

      if (parameters.isEmpty) {
        return '''  String get ${key} => _content['${key}'] ?? ${fallbackValue(value)};\n''';
      }

      final String placeholders = parameters.map((parameter) {
        return '\'${parameter}\': ${parameter},';
      }).join('\n      ');

      return '''  String ${key}(${parameters.join(', ')}) {
        return parsePlaceholder(${fallbackValue(value)}, '${key}', {
          ${placeholders}
        });
      }\n''';
    } else {
      return '''  String get ${key} => _content['${key}'] ?? '';\ n''';
    }
  }
}
